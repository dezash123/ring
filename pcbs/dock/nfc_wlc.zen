load("@stdlib/interfaces.zen", "NotConnected")
R  = Module("@stdlib/generics/Resistor.zen")
C  = Module("@stdlib/generics/Capacitor.zen")
FB = Module("@stdlib/generics/FerriteBead.zen")
PinHeader = Module("@stdlib/kicad/PinHeader.zen")
TP = Module("@stdlib/generics/TestPoint.zen")

# Rails & IO
vdd33  = io("vdd33", Net)   # 3.3V supply rail for CTN73x
gnd    = io("gnd", Net)

scl    = io("scl", Net)     # I2C to optional host (future-proof)
sda    = io("sda", Net)
irq    = io("irq", Net)     # CTN73x -> host interrupt
en     = io("en", Net)      # enable pin (active-high)

# Coil differential to real antenna via a 1x04 header
coil_p = io("coil_p", Net)
coil_n = io("coil_n", Net)

PinHeader(
  name="J_COIL",
  pins=3, rows=1, pitch="2.54mm", orientation="Vertical",
  Pin_1=coil_p, Pin_2=gnd, Pin_3=coil_n
)

# ---- Matching network placeholders (populate during tune) ----
COIL_P_DRV = Net("COIL_P_DRV")    # from CTN73x TXP
COIL_N_DRV = Net("COIL_N_DRV")    # from CTN73x TXN

# Series tuning
C(name="C_SER_P", value="DNP", package="0402", P1=COIL_P_DRV, P2=coil_p)
C(name="C_SER_N", value="DNP", package="0402", P1=COIL_N_DRV, P2=coil_n)

# Shunt tuning (to ground) — typical to hit 13.56 MHz resonance with your coil
C(name="C_SHUNT_P", value="DNP", package="0402", P1=coil_p, P2=gnd)
C(name="C_SHUNT_N", value="DNP", package="0402", P1=coil_n, P2=gnd)

# Probe pads for VNAs / scope while tuning
TP(name="TP_COIL_P", variant="Pad_D1.5mm", P1=coil_p)
TP(name="TP_COIL_N", variant="Pad_D1.5mm", P1=coil_n)

# ---- CTN73x IC ----
# NOTE: Adjust the symbol if your library uses a different name/pin labels.
Component(
  name = "U_WLC_TX",
  footprint = File("@kicad-footprints/Package_QFN.pretty/QFN-32-1EP_5x5mm_P0.5mm.kicad_mod"),
  symbol = Symbol("@kicad-symbols/RF_NFC.kicad_sym:CTN73x"),
  pins = {
    # Power & ground (keep beads + decoupling near IC)
    "VDD": vdd33,
    "GND": gnd,

    # RF differential driver to matching → coil
    "TXP": COIL_P_DRV,
    "TXN": COIL_N_DRV,

    # I2C host interface and control
    "SCL": scl,
    "SDA": sda,
    "IRQ": irq,
    "EN":  en,

    # Optional pins (tie/NC if your symbol has them)
    "GPIO0": NotConnected(),
    "GPIO1": NotConnected(),
  },
  mpn = "CTN732"   # Tx + card emulation; or use CTN730 per your needs
)

# ---- Power integrity (3.3V) ----
# π-filter entry (optional), then bulk + HF caps at the IC
FB(name="FB_VDD", resistance="120Ohm", frequency="100MHz", package="0603", P1=vdd33, P2=Net("VDD_WLC"))
C(name="C_VDD_BULK", value="10uF", package="0603", voltage="10V", P1=Net("VDD_WLC"), P2=gnd)
C(name="C_VDD_HF0",  value="100nF", package="0402", voltage="10V", P1=Net("VDD_WLC"), P2=gnd)
C(name="C_VDD_HF1",  value="100nF", package="0402", voltage="10V", P1=Net("VDD_WLC"), P2=gnd)

# I2C pull-ups to 3.3V (adjust if you bus-share elsewhere)
R(name="R_SCL_PU", value="2.2kOhm", package="0402", P1=scl, P2=vdd33)
R(name="R_SDA_PU", value="2.2kOhm", package="0402", P1=sda, P2=vdd33)

# EN default: pulled-up so the Tx comes up enabled (change to taste)
R(name="R_EN_PU", value="100kOhm", package="0402", P1=en, P2=vdd33)

# IRQ has an on-chip driver; just expose; add ESD if needed at system level
