load("@stdlib/interfaces.zen", "NotConnected")
Y  = Module("@stdlib/generics/Crystal.zen")
C  = Module("@stdlib/generics/Capacitor.zen")
R  = Module("@stdlib/generics/Resistor.zen")
TagConnect = Module("@stdlib/kicad/TagConnect.zen")

# Rails & I/O
iovdd   = io("iovdd", Net)     # 1.8V I/O domain (and VTREF on header)
usbvdd  = io("usbvdd", Net)    # 3.3V USB PHY & analog domain
vregvin = io("vregvin", Net)   # feed 1.8V (allowed 1.8–3.3V)
gnd     = io("gnd", Net)
usb_dp  = io("usb_dp", Net)
usb_dm  = io("usb_dm", Net)

swdio   = io("swdio", Net)     # target SWD out
swclk   = io("swclk", Net)
nreset  = io("nreset", Net)

usb_dp_mcu  = Net("usb_dp_mcu")
usb_dm_mcu  = Net("usb_dm_mcu")

R(name="R_USBDP", value="27Ohm", package="0402", P1=usb_dp_mcu, P2=usb_dp)
R(name="R_USBDM", value="27Ohm", package="0402", P1=usb_dm_mcu, P2=usb_dm)

# Clock
xin  = Net("XIN")
xout = Net("XOUT")
Y(name="X1", frequency="12MHz", load_capacitance="10pF", package="3225_4Pin", XIN=xin, XOUT=xout, GND=gnd)
C(name="C_XIN",  value="10pF", package="0402", voltage="50V", P1=xin,  P2=gnd)
C(name="C_XOUT", value="10pF", package="0402", voltage="50V", P1=xout, P2=gnd)

# Internal regulator output (must be tied to DVDD and decoupled)
vreg_vout = Net("VREG_VOUT")
C(name="C_VREGVOUT", value="1uF", package="0402", voltage="10V", P1=vreg_vout, P2=gnd)

# Analog domain (ADC_AVDD) uses 3.3V rail with local decoupling
adc_avdd = Net("ADC_AVDD")
C(name="C_AVDD_0", value="100nF", package="0402", voltage="10V", P1=adc_avdd, P2=gnd)
C(name="C_AVDD_1", value="1uF",   package="0402", voltage="10V", P1=adc_avdd, P2=gnd)

# ---- RP2040 MCU ----
Component(
  name = "U_RP2040",
  footprint = File("@kicad-footprints/Package_DFN_QFN.pretty/QFN-56-1EP_7x7mm_P0.4mm_EP3.2x3.2mm.kicad_mod"),
  symbol = Symbol("@kicad-symbols/MCU_RaspberryPi.kicad_sym:RP2040"),
  pins = {
    # supplies
    "IOVDD":    iovdd,
    "USB_VDD":  usbvdd,
    "ADC_AVDD": adc_avdd,
    "VREG_IN": vregvin,
    "VREG_VOUT": vreg_vout,
    "DVDD":     vreg_vout,
    "GND":      gnd,

    # usb
    "USB_DP": usb_dp_mcu,
    "USB_DM": usb_dm_mcu,

    # crystal
    "XIN":  xin,
    "XOUT": xout,

    # target SWD on GPIO2/GPIO3 (1.8V domain)
    "GPIO2": swdio,
    "GPIO3": swclk,
    "RUN":   nreset,

    # on-chip SWD (for programming RP2040 itself) — not used on this dock
    "SWCLK": NotConnected(),
    "SWD":   NotConnected(),
    "TESTEN": gnd,         # tie low per datasheet

    # spare GPIOs (NC)
    "GPIO0": NotConnected(),
    "GPIO1": NotConnected(),
    "GPIO4": NotConnected(),
    "GPIO5": NotConnected(),
    "GPIO6": NotConnected(),
    "GPIO7": NotConnected(),
    "GPIO8": NotConnected(),
    "GPIO9": NotConnected(),
    "GPIO10": NotConnected(),
    "GPIO11": NotConnected(),
    "GPIO12": NotConnected(),
    "GPIO13": NotConnected(),
    "GPIO14": NotConnected(),
    "GPIO15": NotConnected(),
    "GPIO16": NotConnected(),
    "GPIO17": NotConnected(),
    "GPIO18": NotConnected(),
    "GPIO19": NotConnected(),
    "GPIO20": NotConnected(),
    "GPIO21": NotConnected(),
    "GPIO22": NotConnected(),
    "GPIO23": NotConnected(),
    "GPIO24": NotConnected(),
    "GPIO25": NotConnected(),
    "GPIO26_ADC0": NotConnected(),
    "GPIO27_ADC1": NotConnected(),
    "GPIO28_ADC2": NotConnected(),
    "GPIO29_ADC3": NotConnected(),

    # QSPI flash interface (wired below)
    "QSPI_SCLK": Net("QSPI_SCLK"),
    "QSPI_SS":   Net("QSPI_SS"),
    "QSPI_SD0":  Net("QSPI_SD0"),
    "QSPI_SD1":  Net("QSPI_SD1"),
    "QSPI_SD2":  Net("QSPI_SD2"),
    "QSPI_SD3":  Net("QSPI_SD3"),
  },
  mpn = "RP2040"
)

# decoupling near rails
C(name="C_IOVDD",   value="100nF", package="0402", voltage="6.3V", P1=iovdd,   P2=gnd)
C(name="C_USBVDD",  value="100nF", package="0402", voltage="10V",  P1=usbvdd,  P2=gnd)
C(name="C_VREGVIN", value="1uF",   package="0402", voltage="10V",  P1=vregvin, P2=gnd)

# ---- External QSPI flash (1.8V domain) ----
# Use the symbol you have; your error shows these pin names:
# ~{CS}, SCLK, SI/SIO0, SO/SIO1, ~{WP}/SIO2, ~{RESET}/SIO3, VCC, GND

Component(
  name = "U_FLASH",
  footprint = File("@kicad-footprints/Package_SO.pretty/SOIC-8_3.9x4.9mm_P1.27mm.kicad_mod"),
  symbol = Symbol("@kicad-symbols/Memory_Flash.kicad_sym:MX25R3235FM1xx0"),
  pins = {
    "VCC": iovdd,
    "GND": gnd,

    "~{CS}":        Net("QSPI_SS"),
    "SCLK":         Net("QSPI_SCLK"),
    "SI/SIO0":      Net("QSPI_SD0"),   # IO0 / SI
    "SO/SIO1":      Net("QSPI_SD1"),   # IO1 / SO
    "~{WP}/SIO2":   Net("QSPI_SD2"),   # IO2 / WP
    "~{RESET}/SIO3":Net("QSPI_SD3"),   # IO3 / RESET (or HOLD on some)
  },
  mpn = "MX25R3235FM1IH0"  # 1.8V-capable; choose the exact sub-variant you can buy
)

# Decoupling to 1.8V (NOT 3.3V)
C(name="C_FLASH_VCC", value="100nF", package="0402", voltage="6.3V", P1=iovdd, P2=gnd)

# Weak pull-ups to 1.8V (same domain as IO rails)
R(name="R_WP",   value="10kOhm", package="0402", P1=Net("QSPI_SD2"), P2=iovdd)
R(name="R_RST",  value="10kOhm", package="0402", P1=Net("QSPI_SD3"), P2=iovdd)

# ---- SWD header to TARGET (1.8V) ----
TagConnect(
  name="J_SWD",
  tag_type="TC2030-IDC-NL-2x03",
  P1=iovdd,    # VTREF advertises 1.8V
  P2=swdio,
  P3=nreset,
  P4=swclk,
  P5=gnd,
  P6=NotConnected()
)
