# =========================================================
# charging_debug_dock.zen — Top-level: ties everything
# =========================================================
load("@stdlib/interfaces.zen", "Power", "Ground", "Usb2")
# Submodules
usb_c_frontend = Module("usb_c_frontend.zen")
ldo_3v3 = Module("ldo_3v3.zen")
liion_charger = Module("liion_charger.zen")
direct_charge_breakout = Module("direct_charge_breakout.zen")
nfc_wlc_breakout = Module("nfc_wlc_breakout.zen")
rp2040_swd_probe = Module("rp2040_swd_probe.zen")

# Nets/rails
GND = Ground("GND")
VBUS_5V = Power("VBUS_5V")
VDD_3V3 = Power("3V3")

# Instantiate front-end USB-C (5V + USB2)
usb_c_frontend(
  name = "pwr_in"
)
# Tie exported rails to our named rails
NetTie = Module("@stdlib/generics/NetTie.zen")
NetTie("NT_5V", pad_size="0.5mm", pin_count=2, P1=VBUS_5V.NET, P2=usb_c_frontend.vbus_5v.NET)
NetTie("NT_GND", pad_size="0.5mm", pin_count=2, P1=GND.NET, P2=usb_c_frontend.gnd.NET)

# 5V -> 3V3 regulator
ldo_3v3(
  name = "ldo",
)
NetTie("NT_LDO_IN", pad_size="0.5mm", pin_count=2, P1=ldo_3v3.vin.NET, P2=VBUS_5V.NET)
NetTie("NT_LDO_G", pad_size="0.5mm", pin_count=2, P1=ldo_3v3.gnd.NET, P2=GND.NET)
NetTie("NT_3V3", pad_size="0.5mm", pin_count=2, P1=VDD_3V3.NET, P2=ldo_3v3.vout.NET)

# Li-ion charger (5V -> VBATT)
liion_charger(
  name = "charger"
)
NetTie("NT_CHG_IN", pad_size="0.5mm", pin_count=2, P1=liion_charger.vin.NET, P2=VBUS_5V.NET)
NetTie("NT_CHG_G", pad_size="0.5mm", pin_count=2, P1=liion_charger.gnd.NET, P2=GND.NET)

# Break out VBATT/GND for direct device charging
direct_charge_breakout(
  name = "direct_batt"
)
NetTie("NT_VBATT_OUT", pad_size="0.5mm", pin_count=2, P1=direct_charge_breakout.vbatt.NET, P2=liion_charger.vbatt.NET)
NetTie("NT_BATT_G", pad_size="0.5mm", pin_count=2, P1=direct_charge_breakout.gnd.NET, P2=GND.NET)

# NFC/WLC breakout (provides 5V/GND + coil terminals)
nfc_wlc_breakout(
  name = "wlc",
)
NetTie("NT_WLC_5V", pad_size="0.5mm", pin_count=2, P1=nfc_wlc_breakout.VIN_5V.NET, P2=VBUS_5V.NET)
NetTie("NT_WLC_G", pad_size="0.5mm", pin_count=2, P1=nfc_wlc_breakout.gnd.NET, P2=GND.NET)

# RP2040 SWD probe — powered from 3V3, USB D+/D- from front-end
rp2040_swd_probe(
  name = "probe"
)
# Power
NetTie("NT_PROBE_3V3", pad_size="0.5mm", pin_count=2, P1=rp2040_swd_probe.vdd.NET, P2=VDD_3V3.NET)
NetTie("NT_PROBE_G", pad_size="0.5mm", pin_count=2, P1=rp2040_swd_probe.gnd.NET, P2=GND.NET)
# USB wiring (D+/D-)
NetTie("NT_USB_DP", pad_size="0.5mm", pin_count=2, P1=rp2040_swd_probe.usb.DP, P2=usb_c_frontend.usb.DP)
NetTie("NT_USB_DN", pad_size="0.5mm", pin_count=2, P1=rp2040_swd_probe.usb.DN, P2=usb_c_frontend.usb.DN)
# VBUS reference (if the probe wants to sense VBUS; optional)
# NetTie("NT_USB_VBUS", pad_size="0.5mm", pin_count=2, P1=rp2040_swd_probe.usb.VBUS, P2=VBUS_5V.NET)

# ---- Notes / integration hints ----
# - Swap placeholder connectors/footprints (USB-C receptacle, LDO, charger, RP2040) to your exact parts.
# - For production USB-C, add proper ESD + OVP + current limiting, and consider a Type-C sink controller if you need >5V PDOs.
# - If you prefer NFC-WLC only (no wired charge), you can omit the liion_charger + direct_breakout and just power the WLC board.
# - If you want the RP2040 to power the *target* through VTREF, keep VTREF as an input sense; don’t back-drive target power.
# - Add series resistors/level-safe routing as needed for SWD signals and USB D+/D- length-matching/impedance control.

# (No explicit exports on top-level — it’s a finished board)
